# On TCA: Article reaction

Article
https://rodschmidt.com/posts/composable-architecture-experience/

## Общее впечатление

Классная статья с типичными минусами и мнением early-adopters.
Крутые ответы и дискуссия дальше по теме с участием Stephen Celis. 

## Point #1. Complicated.

> You need to learn about reducers, stores, and scoping of state and actions

Учить нужно архитектурку и как ее варить.

Как и любую другую. На онбординге в компанию нужно привыкать к архитектуре. Но в чем разница, к какой архитектуре привыкать? К самописной архитектуре любой компании, или к общей TCA? Нет разницы. 

Это как с дизайн паттернами. Вот их придумали, назвали одними именами, есть небольшая вариация, но мы теперь хотя бы можем оперировать одними и теми же названиями, понимая о чем идет речь. 

Strategy? Cool! просто поведение ведем по разным веткам 

Reducer? Cool, просто объединяем в Result каждый новый элемент. как `[0,2].reduce(0, +)`, так и `&state.reduce(action)`.

Effect? Круто, что-то с сайд эффектами. Работа с внешними зависимостями. И с асинхронностью мира. А, в тса то еще и тестировать можно их? Ну круто, да, __сейчас привыкну__, погодите чуть.

Привыкайте же, эвридей нужно учиться и бежать чтобы стоять на месте и работать где-то. Фичи и требования будут приходить, надо адаптироваться. Это _нормально_

---

TCA при этом всем со своим learning curve в отличие от других архитектур/подходов имеет:

- [видео](https://www.pointfree.co/collections/composable-architecture)
- [интерактивное обучение](https://pointfreeco.github.io/swift-composable-architecture/main/tutorials/meetcomposablearchitecture/)
- [example проекты](https://github.com/pointfreeco/swift-composable-architecture?tab=readme-ov-file#examples)
- [целый апп-игра](https://github.com/pointfreeco/isowords) написанная на TCA авторами

Тут вот даже в [Lickability](https://lickability.com/blog/how-to-learn-tca/) советуют так подходить:

> To summarize, we recommend following these steps to start your TCA journey:
> - Check out the README to understand the fundamentals & terminology
> - Follow the Getting Started guide
> - Do Chapter 1 of the Point-Free tutorials
> - Dip into the video series
> - Do Chapter 2 of the Point-Free tutorials

И тогда как TCA выглядит на фоне других арихтектур/подходов, где _тоже_ надо учиться правильно варить? 

Сильно выгоднее, т.к. в этой архитектуре переживают за необходимость обучения.


Сложная она? Ну да, это не ванилла, это не обычный Redux, это не MVC. Но очень близко ко всему, и при этом за эту сложность отплатит:
- классной тестируемостью
- контролем зависимостей и эффектов
- возможностью разделять и компоновать редьюсеры

---

И мы планируем адоптить в будущем, а версия уже далеко не 0.x, и многие подходы устоялись.

## Point #2. Releases and upgrading large codebase

Очень валидный и важный поинт про то, что релизы TCA очень часто добавляют новые фичи (не факт, что нужные всем адоптерам), и ты вынужден обновлять _всю_ кодовую базу сразу.

Для этого есть инструменты депрекейтов, хорошо работающие у TCA. Как работающие? Ворнинги, которые расскажут, что не так в старом подходе, и как перейти на новый. Более, чем достаточно.

Может ли случиться так, что мы останемся на какой-то версии и не сможем обновиться, и надолго зависнем с одной версией? Может, тогда пригодится fork, как делают в [Arc browser](https://www.merowing.info/the-composable-architecture-best-practices/).


## Point #3 and #4. Architecture and Performance

Encapsulation? Их есть у нас! 

Performance? Сделаем!

Не надо делать один Store на все приложение, разделяйте! В web-based Redux давно признали, что единый Store работает ужасно.

> the idea of using a single global store to store all of your application state is a really, really bad idea.
> 
> [Redux is half of a pattern](https://dev.to/davidkpiano/redux-is-half-of-a-pattern-2-2-4jo3)

И из-за этого появилось очень много паттернов, как это отпимизировать. _Очень много_. Можно взять их за пример.

Но как правило - не делайте один Store. Инкапсуляция, перформанс - всему становится плохо.

## Company organizational issues

TCA for everyone? Ну да, но не совсем. В компании уже есть и будут какие-то подходы устаревшие, никто не перепишет старое на TCA просто потому что захочет. Да и даже MVVM мало кто перепишет быстро, все будет жить одновременно.

При этом платформенной команде и адоптерам TCA нужно сделать четкие границы общения фичей и приложения.

Нам будет без разницы, что там происходит в фича модуле, пока он получает инпуты и отдает аутпуты с помощью сервисов. А внутри - да ~~хоть Viper~~ (шутка). Внутри на самом деле будут в любом случае разные подходы. Old MVVM, new MVVM, TCA, или какой-то монстр чтобы разобраться со сложностью экрана, которая будет в любой архитектуре (например, на сложной карте гайдов или в сложном экране списка билетов, на главной эксплора с серч формой единой для всех).

## Company Risks.

3rd party фреймворк - валидный поинт. Но он легко кроется тем, что мы

- можем форкнуть
- у Pointfree прекрасный подход к депрекейтам и репутация
- не будем переезжать везде и сразу, а потихоньку


## Наш план адоптерства

! 

**Какие вещи мне не нравятся в TCA, и я бы добавил правил поверх vanilla TCA**

!

### One Store

Уже написал. Я вижу так, что стор должен быть один на Feature модуль. Как максимум - один на Product модуль, объединяющий несколько Feature, чтобы было удобнее шарить стейт. Но мне видится это либо очень редким случаем, либо вообще невозможным.

### Testing exhaustivity

Деды говорят, что тесты должны тестировать не реализацию, а контракт.

Exhaustive tests часто тестируют как раз таки реализацию, и тесты становятся очень сложными для рефакторинга.

Я на эту тему еще постов поделаю, но пока ощущение такое:

non-exhaustive tests: 95%
exhaustive tests: 5%

примерно такое соотношение.

Потому что мы хотим тестировать контракт, тестировать что юнит/система/класс/сервис/набор функций работают как ожидает их user/caller. И не хотелось бы тестировать то, КАК они это делают. Только то, что они обещают.

Вот вам лонгрид, если уже хотите чуть подробнее:

http://www.jamesshore.com/v2/projects/nullables/testing-without-mocks

### Boundaries

Actions нужно разделять, они разные. Об этом писал еще [Кшиштоф в посте о практиках в TCA](https://www.merowing.info/the-composable-architecture-best-practices/).

- view action (button tap)
- model action (received response)
- delegate action (edit completed, someone react)


### Modular structure

В примерах TCA часто модули - это очень сильно вложенное дерево.

App -> List -> Details -> Button

Мы же привыкли, что у нас очень плоская структура модулей:

App -> List, Details, Edit -> Button.

List, Details, Edit должны быть на одном уровне и не знать друг о друге. Так мы добиваемся инкапсуляции и возможности работать одновременно в разных модулях. А точка синхронизации выше Feature модулей.

В примерах TCA не так. Но это возможно сделать корректно с более плоской структурой.

### Shared state

Внутри одного стора и разных редьюсеров появляется проблема шареного стейта, который могут слушать/изменять несколько вложенных reducers.

Уже сейчас TCA как раз выходит [с фичей @Shared](https://github.com/pointfreeco/swift-composable-architecture/discussions/2857) для шаринга внутри стора.

Шаринг между сторами достигается зависимостями и сервисами вокруг разных сторов. Проблема решаема, и везде бы нуждалась в решении.

В TCA просто уже есть опция для шаринга между редьюсерами в одном сторе.

### Macro

Пока в моем списке рисков, т.к. адоптить макросы == приносить SwiftSyntax в код. Это большой пакет, который повлияет на компиляцию и время сборки. Тут надо еще поизучать.

Но плюсы от макросов конечно есть. Правда, того же можно было бы достигнуть например с Sourcery. Но это другая тема уже.
